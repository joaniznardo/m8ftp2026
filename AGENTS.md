# AGENTS.md — sftpgo-lab

Infrastructure-as-code lab for practising FTP/FTPS/FTPES using Containerlab,
SFTPGo, FRR, CoreDNS and FileZilla (WebRTC/noVNC). Written in Bash, YAML, JSON
and Dockerfile. No compiled language is involved.

Each stage has its own topology file in `topologies/etapaN.yml`. Official Docker
images are used for the server (`drakkan/sftpgo`), client (`linuxserver/filezilla`),
router (`frrouting/frr`) and DNS (`coredns/coredns`). Only the switch uses a
custom image (`sftpgo-lab/switch`).

---

## Quick-reference commands

```bash
# Check host prerequisites (Docker, containerlab, mkcert)
./lab.sh check

# Build the custom switch image (only custom image needed for stages 1-4)
./lab.sh build
docker build -t sftpgo-lab/switch:latest docker/switch/

# Deploy a specific stage (requires sudo for containerlab)
./lab.sh deploy 1                  # Stage 1: plain FTP
./lab.sh deploy 2                  # Stage 2: FTPES + FTPS (needs certs first)

# Inspect running nodes
./lab.sh status

# Open a shell on any node
./lab.sh shell client              # default: client
./lab.sh shell server
./lab.sh shell router-frr
./lab.sh shell coredns

# Tail logs for a node
./lab.sh logs server               # default: server

# Generate TLS certificates (Stage 2+)
./lab.sh certs

# Full Stage-2 cycle (certs → deploy)
./lab.sh certs && ./lab.sh deploy 2

# Tear down everything
./lab.sh destroy
```

There is no test suite. "Testing" means deploying the lab and verifying
connectivity manually:

```bash
# DNS resolution check (run inside client container)
docker exec clab-sftpgo-lab-client dig demoftp.test @10.50.0.53
docker exec clab-sftpgo-lab-client ping -c 3 demoftp.test

# FTP reachability (Stage 1 — plain FTP via curl)
docker exec clab-sftpgo-lab-client \
  curl -v ftp://ftpuser:ftppassword@demoftp.test/

# FTP upload test
docker exec clab-sftpgo-lab-client \
  curl -s ftp://ftpuser:ftppassword@demoftp.test/ -T /etc/hostname

# TLS handshake verification (Stage 2)
docker exec clab-sftpgo-lab-client \
  openssl s_client -connect demoftp.test:21 -starttls ftp \
    -CAfile /home/ftpuser/certs/rootCA.pem

# Passive-port listen check (run inside server container)
docker exec clab-sftpgo-lab-server ss -tlnp | grep -E ":(21|990|8080)"

# SFTPGo admin API — check users
docker exec clab-sftpgo-lab-server bash -c '
  TOKEN=$(curl -s http://127.0.0.1:8080/api/v2/token -u admin:admin | jq -r .access_token)
  curl -s http://127.0.0.1:8080/api/v2/users -H "Authorization: Bearer $TOKEN" | jq
'
```

---

## Repository layout

```
lab.sh                  # Unified management script (deploy N, destroy, build, certs, shell, logs)
.gitignore              # Ignores clab-*/, .lab-stage, certs/
topologies/
  etapa1.yml            # Stage 1: plain FTP (5 nodes)
  etapa2.yml            # Stage 2: FTPES + FTPS (5 nodes + TLS)
  etapa3.yml            # Stage 3: S3 backend (6 nodes + RustFS/MinIO)
  etapa4.yml            # Stage 4: OIDC auth (6 nodes + Keycloak)
  etapa5.yml            # Stage 5: CLI clients (7 nodes + lftp + rclone)
  etapa6.yml            # Stage 6: Reverse proxy (8 nodes + nginx/angie)
docker/
  switch/               # Dockerfile + entrypoint.sh  (Linux bridge — only custom image for stages 1-4)
  client-lftp/          # Dockerfile + entrypoint.sh  (Stage 5)
  client-rclone/        # Dockerfile + entrypoint.sh  (Stage 5)
  proxy/                # Dockerfile + entrypoint.sh  (Stage 6)
  web-nginx/            # Dockerfile + entrypoint.sh  (Stage 6)
  web-angie/            # Dockerfile + entrypoint.sh  (Stage 6)
configs/
  frr/                  # frr.conf, daemons, vtysh.conf
  coredns/              # Corefile + zones/db.test + zones/db.*.in-addr.arpa
  switch/               # init-bridge.sh (bind-mounted into the switch node)
  sftpgo/
    etapa1/             # sftpgo.json  — plain FTP, port 21
    etapa2/             # sftpgo.json  — FTPES (21) + FTPS (990) + HTTPS admin
    etapa3/             # sftpgo.json + setup script (RustFS S3)
    etapa4/             # sftpgo.json + setup script (Keycloak OIDC)
scripts/
  server-init.sh        # Network config + ftpuser creation via REST API (all stages)
  client-init.sh        # Network config for FileZilla Alpine container (all stages)
  router-init.sh        # LAN interface config for FRR (all stages)
  init-client-lftp.sh   # Stage 5: lftp client init
  init-client-rclone.sh # Stage 5: rclone client init
  init-proxy.sh         # Stage 6: reverse proxy init
  init-web-nginx.sh     # Stage 6: nginx web server init
  init-web-angie.sh     # Stage 6: angie web server init
certs/                  # Generated by ./lab.sh certs (mkcert) — gitignored
etapa1/                 # instruccions-etapa1.md
etapa2/                 # instruccions-etapa2.md
...
presentation/
  index.html            # reveal.js presentation (local, no CDN)
  reveal.js/            # reveal.js 5.1.0 source
```

---

## Docker images used

| Node | Image | Type | Notes |
|------|-------|------|-------|
| server | `drakkan/sftpgo:latest` | Official (Debian) | Runs as UID 1000, config via env vars + sftpgo.json |
| client | `lscr.io/linuxserver/filezilla:latest` | Official (Alpine) | Web UI on port 3001 (HTTPS), s6-overlay init |
| router-frr | `frrouting/frr:latest` | Official | FRR starts automatically via entrypoint |
| coredns | `coredns/coredns:latest` | Official (scratch) | No shell — network configured via nsenter from lab.sh |
| switch-lan | `sftpgo-lab/switch:latest` | Custom (Ubuntu 24.04) | Linux bridge, only custom image for stages 1-4 |

---

## Network

- **LAN:** 10.50.0.0/24
- **Router (gateway):** 10.50.0.1
- **Client (FileZilla):** 10.50.0.10 — web UI on host port 3001
- **Server (SFTPGo):** 10.50.0.20 — admin UI on host port 8081
- **CoreDNS:** 10.50.0.53
- **Domain:** `demoftp.test`

---

## Key architectural decisions

- **Per-stage topology files:** Each stage has its own `topologies/etapaN.yml`.
  `lab.sh deploy N` selects the correct one. The `.lab-stage` file tracks
  which stage is currently deployed.
- **Official images + exec:** Official Docker images run their own entrypoints.
  Containerlab `exec:` commands configure networking and create users via API.
  Init scripts must NOT start services (they're already running).
- **CoreDNS via nsenter:** The CoreDNS image is scratch-based (no shell).
  Network configuration is done from the host using `nsenter` into the
  container's network namespace. This is handled by `lab.sh`'s
  `_configure_coredns()` function, called after `containerlab deploy`.
- **SFTPGo user creation:** The `server-init.sh` script creates `ftpuser` via
  the REST API in a background subshell. It polls `/api/v2/token` (not
  `/api/v2/status`, which requires auth) as a health check.
- **force_passive_ip:** All `sftpgo.json` files set `force_passive_ip` to
  `10.50.0.20` — critical for FTP passive mode in the containerlab network.

---

## Bash style (lab.sh and all scripts)

- **Shebang:** always `#!/bin/bash`.
- **Safety flags:** `set -euo pipefail` in `lab.sh`; `set -e` in init scripts
  that run inside containers (pipefail is omitted there deliberately, as some
  iproute2 commands use pipelines that may return non-zero on benign errors).
- **Variables:** UPPER_SNAKE_CASE for environment/config vars; lower_snake_case
  for local variables. Always quote: `"$VAR"`, never bare `$VAR`.
- **Defaults:** use `${VAR:-default}` for every env variable a script reads, so
  it works both standalone and when injected by containerlab.
- **Error helpers:** use the `info / ok / warn / error` functions defined in
  `lab.sh`; do not use raw `echo` for status messages in that file.
- **Functions:** one blank line between functions; comment each one with a
  `# ─── Funció: … ──────────` banner at the same indentation level.
- **Indentation:** 4 spaces (no tabs).
- **Line length:** soft limit 100 characters; break long `&&`/`||` chains with
  a trailing `\` and indent continuation by 4 extra spaces.
- **Graceful errors:** commands that may legitimately fail should be followed
  by `|| true` or `2>/dev/null || true`, not by bare `|| true` without comment.
- **`exec` at the end:** every entrypoint that must keep the container alive
  ends with `exec tail -f /dev/null`; every entrypoint that hands off to a
  daemon ends with `exec <daemon> …`.

---

## Dockerfile style

- **Base image:** `ubuntu:24.04` for all custom images; pin exact tags, never
  `latest` for the base.
- **Third-party images:** use `latest` only when the lab's own images control
  the version (e.g. `frrouting/frr:latest`, `coredns/coredns:latest`).
- **`RUN` grouping:** one `RUN apt-get update && apt-get install … && apt-get
  clean && rm -rf /var/lib/apt/lists/*` block per logical install step; never
  split `update` and `install` into separate layers.
- **`--no-install-recommends`:** always pass this flag to apt-get.
- **Comments inside `RUN`:** group packages by purpose with an inline comment
  on the line before the first package of each group.
- **`ARG` before the `RUN` that uses it:** never declare `ARG` at the top of
  the file unless it is needed there; keep it close to its use.
- **`COPY` + `chmod`:** combine into a single `RUN chmod +x` immediately after
  `COPY` rather than adding a second layer later.
- **`EXPOSE`:** document every port that the container actually uses, with a
  trailing comment explaining it.
- **`ENTRYPOINT`:** JSON array form (`["…"]`), never shell form.
- **`ENV`:** declare only variables that must survive into the running container;
  build-time-only values belong in `ARG`.
- **No `CMD`:** all images use only `ENTRYPOINT`; the entrypoint script is
  self-contained.

---

## YAML (topologies/etapaN.yml)

- 2-space indentation throughout.
- Every node has a descriptive comment block starting with
  `# ─── NODE NAME ──────…` aligned to fill ~78 characters.
- Future/commented-out nodes and links are kept in-file, commented out with
  `#`, so they can be activated by removing the comment character alone.
- Inline comments on ports use `# Purpose (direction)` format, e.g.
  `"8081:8080"   # SFTPGo web admin (des del host)`.
- Never use YAML anchors; prefer explicit repetition for clarity.
- All bind paths use `../` prefix (relative to topology file in `topologies/`).

---

## JSON (sftpgo.json)

- 2-space indentation.
- Every configuration file includes only the keys relevant to that stage;
  omit keys that keep their SFTPGo defaults.
- When a key is intentionally empty (`""`), include it explicitly; do not
  omit it, as the absence vs. empty-string distinction matters to SFTPGo.
- Comments are not valid JSON: use a top-level `"_comentari"` key for
  human-readable notes in snippet/example files (never in files consumed
  directly by SFTPGo at runtime).
- TLS mode values: `0` = disabled (plain FTP or mixed if global certs set), `1` = explicit required (FTPES), `2` = implicit (FTPS).

---

## DNS zone files

- SOA serial format: `YYYYMMDDNN` (e.g. `2026022001`).
- Record columns: name, class (`IN`), type, value — aligned with spaces, not
  tabs, to at least 4-character columns.
- Future records are commented out with `;` and kept in file.
- Both a forward zone (`db.test`) and a reverse zone
  (`db.50.10.in-addr.arpa`) must be maintained in sync whenever a node IP
  changes.

---

## Adding a new lab stage

1. Create `topologies/etapaN.yml` based on an existing stage topology.
2. Add the node and its IP to `configs/coredns/zones/db.test` (A record) and
   `configs/coredns/zones/db.50.10.in-addr.arpa` (PTR record); bump the SOA
   serial (`YYYYMMDDNN`).
3. Create `configs/sftpgo/etapaN/` with at minimum a `sftpgo.json`.
4. If new custom images are needed, create `docker/<name>/` with a Dockerfile
   and entrypoint.sh; register them in `lab.sh`'s `_required_images_for_stage()`.
5. Add init scripts in `scripts/` for any new nodes (network + service config).
6. Add an `etapaN/instruccions-etapaN.md` following the existing structure
   (architecture diagram → prerequisites → numbered steps → summary table →
   10 reflection questions).
7. Add slides for the new stage to `presentation/index.html`.
8. Extend `lab.sh` with any new sub-commands needed.
